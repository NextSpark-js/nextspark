import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import chalk from 'chalk';
import ora from 'ora';

interface InitOptions {
  force?: boolean;
}

/**
 * Generate initial empty registries with valid structure
 * These allow the project to compile before running 'nextspark generate'
 */
function generateInitialRegistries(registriesDir: string): void {
  // Block Registry (with BLOCK_COMPONENTS for loader compatibility)
  writeFileSync(join(registriesDir, 'block-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
import type { ComponentType } from 'react'

export const BLOCK_REGISTRY: Record<string, {
  name: string
  slug: string
  componentPath: string
  fields?: unknown[]
  examples?: unknown[]
}> = {}

// Lazy-loaded block components - populated by 'nextspark generate'
export const BLOCK_COMPONENTS: Record<string, React.LazyExoticComponent<ComponentType<any>>> = {}
`);

  // Theme Registry
  writeFileSync(join(registriesDir, 'theme-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const THEME_REGISTRY: Record<string, unknown> = {}
`);

  // Entity Registry
  writeFileSync(join(registriesDir, 'entity-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const ENTITY_REGISTRY: Record<string, unknown> = {}
`);

  writeFileSync(join(registriesDir, 'entity-registry.client.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const CLIENT_ENTITY_REGISTRY: Record<string, unknown> = {}
export function parseChildEntity(path: string) { return null }
export function getEntityApiPath(entity: string) { return \`/api/\${entity}\` }
export function clientMetaSystemAdapter() { return {} }
export type ClientEntityConfig = Record<string, unknown>
`);

  // Billing Registry
  writeFileSync(join(registriesDir, 'billing-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const BILLING_REGISTRY = { plans: [], features: [] }
`);

  // Plugin Registry
  writeFileSync(join(registriesDir, 'plugin-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const PLUGIN_REGISTRY: Record<string, unknown> = {}
`);

  // Testing Registry
  writeFileSync(join(registriesDir, 'testing-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const FLOW_REGISTRY: Record<string, unknown> = {}
export const FEATURE_REGISTRY: Record<string, unknown> = {}
export const TAGS_REGISTRY: Record<string, unknown> = {}
export const COVERAGE_SUMMARY = { total: 0, covered: 0 }
export type FlowEntry = unknown
export type FeatureEntry = unknown
`);

  // Docs Registry
  writeFileSync(join(registriesDir, 'docs-registry.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export const DOCS_REGISTRY = { sections: [], pages: [] }
export type DocSectionMeta = { title: string; slug: string }
`);

  // Index
  writeFileSync(join(registriesDir, 'index.ts'), `// Auto-generated by nextspark init - Run 'nextspark generate' to populate
export * from './block-registry'
export * from './theme-registry'
export * from './entity-registry'
export * from './entity-registry.client'
export * from './billing-registry'
export * from './plugin-registry'
export * from './testing-registry'
export * from './docs-registry'
`);
}

export async function initCommand(options: InitOptions): Promise<void> {
  const spinner = ora('Initializing NextSpark project...').start();
  const projectRoot = process.cwd();

  try {
    // 1. Create .nextspark/registries directory
    const nextspark = join(projectRoot, '.nextspark');
    const registriesDir = join(nextspark, 'registries');

    if (!existsSync(registriesDir) || options.force) {
      mkdirSync(registriesDir, { recursive: true });
      spinner.text = 'Creating .nextspark/registries/';

      // 2. Generate initial registries with valid structure
      generateInitialRegistries(registriesDir);
      spinner.text = 'Generated initial registries';
    }

    // 3. Create/update tsconfig.json paths
    const tsconfigPath = join(projectRoot, 'tsconfig.json');
    if (existsSync(tsconfigPath)) {
      spinner.text = 'Updating tsconfig.json paths...';
      const tsconfig = JSON.parse(readFileSync(tsconfigPath, 'utf-8'));
      tsconfig.compilerOptions = tsconfig.compilerOptions || {};
      tsconfig.compilerOptions.paths = {
        ...tsconfig.compilerOptions.paths,
        "@nextsparkjs/registries": ["./.nextspark/registries/index.ts"],
        "@nextsparkjs/registries/*": ["./.nextspark/registries/*"],
      };
      writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2));
    }

    // 4. Create .env.example if not exists
    const envExample = join(projectRoot, '.env.example');
    if (!existsSync(envExample)) {
      const envContent = `# NextSpark Configuration
DATABASE_URL="postgresql://user:password@localhost:5432/db"
BETTER_AUTH_SECRET="your-secret-here-min-32-chars"
BETTER_AUTH_URL=http://localhost:3000
NEXT_PUBLIC_APP_URL=http://localhost:3000
`;
      writeFileSync(envExample, envContent);
      spinner.text = 'Created .env.example';
    }

    spinner.succeed('NextSpark initialized successfully!');

    console.log(chalk.blue('\nNext steps:'));
    console.log('  1. Copy .env.example to .env and configure');
    console.log('  2. Run: nextspark generate  (to populate registries)');
    console.log('  3. Run: nextspark dev');

  } catch (error) {
    spinner.fail('Initialization failed');
    if (error instanceof Error) {
      console.error(chalk.red(error.message));
    }
    process.exit(1);
  }
}
