import { existsSync, statSync, readdirSync, mkdirSync, copyFileSync, readFileSync } from 'node:fs';
import { join, dirname, relative } from 'node:path';
import chalk from 'chalk';
import ora from 'ora';
import { getCoreDir, getProjectRoot } from '../utils/paths.js';

interface SyncAppOptions {
  dryRun?: boolean;
  force?: boolean;
  backup?: boolean;
  verbose?: boolean;
}

// Patterns to exclude from template sync
// (templates) = Next.js route groups auto-generated by theme system
const EXCLUDED_TEMPLATE_PATTERNS = ['(templates)'];

// Display limits for file listings
const MAX_VERBOSE_FILES = 10;
const MAX_SUMMARY_FILES = 5;

/**
 * Recursively get all files in a directory
 */
function getAllFiles(dir: string, baseDir: string = dir): string[] {
  const files: string[] = [];

  if (!existsSync(dir)) {
    return files;
  }

  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relativePath = relative(baseDir, fullPath);

    if (entry.isDirectory()) {
      files.push(...getAllFiles(fullPath, baseDir));
    } else if (entry.isFile()) {
      // Skip .DS_Store and README.md
      if (entry.name !== '.DS_Store' && entry.name !== 'README.md') {
        files.push(relativePath);
      }
    }
  }

  return files;
}

/**
 * Copy a file, creating parent directories if needed
 */
function copyFile(source: string, target: string): void {
  const targetDir = dirname(target);
  if (!existsSync(targetDir)) {
    mkdirSync(targetDir, { recursive: true });
  }
  copyFileSync(source, target);
}

/**
 * Backup a directory by copying it
 */
function backupDirectory(source: string, target: string): void {
  if (!existsSync(source)) {
    return;
  }

  const files = getAllFiles(source);
  for (const file of files) {
    const sourcePath = join(source, file);
    const targetPath = join(target, file);
    copyFile(sourcePath, targetPath);
  }
}

/**
 * Get core package version
 */
function getCoreVersion(coreDir: string): string {
  try {
    const pkgPath = join(coreDir, 'package.json');
    const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
    return pkg.version || 'unknown';
  } catch {
    return 'unknown';
  }
}

export async function syncAppCommand(options: SyncAppOptions): Promise<void> {
  const spinner = ora({ text: 'Preparing sync...', isSilent: options.dryRun }).start();

  try {
    const coreDir = getCoreDir();
    const projectRoot = getProjectRoot();
    const coreVersion = getCoreVersion(coreDir);

    // Templates directory in core
    const templatesDir = join(coreDir, 'templates', 'app');

    // Target app directory in project
    const appDir = join(projectRoot, 'app');

    // Verify templates directory exists
    if (!existsSync(templatesDir)) {
      spinner.fail('Templates directory not found in @nextsparkjs/core');
      console.error(chalk.red(`\n  Expected path: ${templatesDir}`));
      process.exit(1);
    }

    // Verify app directory exists (project must be initialized)
    if (!existsSync(appDir)) {
      spinner.fail('No /app directory found');
      console.error(chalk.red('\n  This project does not have an /app folder.'));
      console.error(chalk.yellow('  Run "nextspark init" first to initialize your project.\n'));
      process.exit(1);
    }

    spinner.text = 'Scanning template files...';

    // Get all template files (excluding auto-generated folders)
    const templateFiles = getAllFiles(templatesDir)
      .filter(f => !EXCLUDED_TEMPLATE_PATTERNS.some(pattern => f.startsWith(pattern)));

    // Get all existing app files
    const existingAppFiles = getAllFiles(appDir);

    // Determine which files are custom (not in templates)
    const customFiles = existingAppFiles.filter(f => !templateFiles.includes(f));

    // Files that will be updated
    const filesToUpdate = templateFiles;

    spinner.succeed('Scan complete');

    // Show summary
    console.log(chalk.cyan(`\n  Syncing /app with @nextsparkjs/core@${coreVersion}...\n`));

    if (options.dryRun) {
      console.log(chalk.yellow('  [DRY RUN] No changes will be made\n'));
    }

    if (options.verbose) {
      console.log(chalk.gray('  Files to sync:'));
      for (const file of filesToUpdate) {
        const targetPath = join(appDir, file);
        const status = existsSync(targetPath) ? chalk.yellow('update') : chalk.green('create');
        console.log(chalk.gray(`    ${status} ${file}`));
      }
      console.log();
    }

    // Show stats
    console.log(chalk.white(`  Template files: ${filesToUpdate.length}`));
    console.log(chalk.white(`  Custom files preserved: ${customFiles.length}`));

    if (customFiles.length > 0 && options.verbose) {
      console.log(chalk.gray('\n  Custom files (will be preserved):'));
      for (const file of customFiles.slice(0, MAX_VERBOSE_FILES)) {
        console.log(chalk.gray(`    - ${file}`));
      }
      if (customFiles.length > MAX_VERBOSE_FILES) {
        console.log(chalk.gray(`    ... and ${customFiles.length - MAX_VERBOSE_FILES} more`));
      }
    }

    // Confirmation prompt (unless --force or --dry-run)
    if (!options.force && !options.dryRun) {
      console.log(chalk.yellow(`\n  This will overwrite ${filesToUpdate.length} core template files.`));
      console.log(chalk.gray('  Run with --dry-run to preview changes, or --force to skip this prompt.\n'));

      try {
        const { confirm } = await import('@inquirer/prompts');
        const confirmed = await confirm({
          message: 'Proceed with sync?',
          default: true,
        });

        if (!confirmed) {
          console.log(chalk.yellow('\n  Sync cancelled.\n'));
          process.exit(0);
        }
      } catch (promptError) {
        console.error(chalk.red('\n  Failed to load confirmation prompt. Use --force to skip.\n'));
        process.exit(1);
      }
    }

    // Perform backup if requested
    if (options.backup && !options.dryRun) {
      const backupDir = join(projectRoot, `app.backup.v${coreVersion}.${Date.now()}`);
      spinner.start('Creating backup...');
      backupDirectory(appDir, backupDir);
      spinner.succeed(`Backup created: ${relative(projectRoot, backupDir)}`);
    }

    // Perform sync
    if (!options.dryRun) {
      spinner.start('Syncing files...');

      let updated = 0;
      let created = 0;

      for (const file of filesToUpdate) {
        const sourcePath = join(templatesDir, file);
        const targetPath = join(appDir, file);
        const isNew = !existsSync(targetPath);

        copyFile(sourcePath, targetPath);

        if (isNew) {
          created++;
        } else {
          updated++;
        }

        if (options.verbose) {
          spinner.text = `Syncing: ${file}`;
        }
      }

      spinner.succeed(`Synced ${filesToUpdate.length} files (${updated} updated, ${created} created)`);
    }

    // Success message
    console.log(chalk.green('\n  \u2705 Sync complete!\n'));

    if (customFiles.length > 0) {
      console.log(chalk.gray(`  Preserved ${customFiles.length} custom file(s):`));
      for (const file of customFiles.slice(0, MAX_SUMMARY_FILES)) {
        console.log(chalk.gray(`    - app/${file}`));
      }
      if (customFiles.length > MAX_SUMMARY_FILES) {
        console.log(chalk.gray(`    ... and ${customFiles.length - MAX_SUMMARY_FILES} more\n`));
      } else {
        console.log();
      }
    }

  } catch (error) {
    spinner.fail('Sync failed');
    if (error instanceof Error) {
      console.error(chalk.red(`\n  Error: ${error.message}\n`));
      if (options.verbose && error.stack) {
        console.error(chalk.gray(`  Stack trace:\n${error.stack}\n`));
      }
    }
    process.exit(1);
  }
}
