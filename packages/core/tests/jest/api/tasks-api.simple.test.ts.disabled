/**
 * Tasks API Basic Tests
 * Testing core functionality for Task endpoints without metadata
 */

import { NextRequest } from 'next/server';

// Mock environment variables
process.env.NEXT_PUBLIC_BASE_URL = 'http://localhost:3000';
process.env.API_RATE_LIMIT_REQUESTS = '100';
process.env.API_RATE_LIMIT_WINDOW = '900000';

// Mock the database functions
jest.mock('@/core/lib/db', () => ({
  queryWithRLS: jest.fn(),
  mutateWithRLS: jest.fn(),
  query: jest.fn()
}));

// Mock auth functions
jest.mock('@/core/lib/api/auth', () => ({
  validateApiKey: jest.fn(),
  handleCorsPreflightRequest: jest.fn()
}));

// Mock MetaService
jest.mock('@/core/lib/services/meta.service');

import { GET, POST } from '@/app/api/v1/tasks/route';
import { GET as GET_BY_ID, PATCH, DELETE } from '@/app/api/v1/tasks/[id]/route';
import { validateApiKey } from '@/core/lib/api/auth';
import { queryWithRLS, mutateWithRLS } from '@/core/lib/db';

const mockValidateApiKey = validateApiKey as jest.MockedFunction<typeof validateApiKey>;
const mockQueryWithRLS = queryWithRLS as jest.MockedFunction<typeof queryWithRLS>;
const mockMutateWithRLS = mutateWithRLS as jest.MockedFunction<typeof mutateWithRLS>;

describe('Tasks API Basic Tests', () => {
  const validApiKey = 'testkey_validkey123';
  const mockUserId = 'user-123';
  const mockTaskId = 'task-456';

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock successful API key validation
    mockValidateApiKey.mockResolvedValue({
      isValid: true,
      keyData: {
        id: 'api-key-id',
        name: 'Test Key',
        scopes: ['tasks:read', 'tasks:write'],
        userId: mockUserId,
        isActive: true,
        usageCount: 0,
        lastUsed: null,
        expiresAt: null,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      },
      rateLimitStatus: {
        limit: 100,
        remaining: 99,
        reset: Date.now() + 900000
      }
    });
  });

  describe('GET /api/v1/tasks', () => {
    test('should list tasks successfully', async () => {
      const mockTasks = [
        {
          id: 'task-1',
          title: 'Test Task 1',
          description: 'First test task',
          completed: false,
          createdAt: '2023-01-01T00:00:00Z',
          updatedAt: '2023-01-01T00:00:00Z',
          user_id: mockUserId,
          user_email: 'test@example.com',
          user_firstName: 'Test',
          user_lastName: 'User'
        },
        {
          id: 'task-2',
          title: 'Test Task 2',
          description: 'Second test task',
          completed: true,
          createdAt: '2023-01-02T00:00:00Z',
          updatedAt: '2023-01-02T00:00:00Z',
          user_id: mockUserId,
          user_email: 'test@example.com',
          user_firstName: 'Test',
          user_lastName: 'User'
        }
      ];

      mockQueryWithRLS.mockResolvedValueOnce([{ count: '2' }]); // Total count
      mockQueryWithRLS.mockResolvedValueOnce(mockTasks); // Tasks data

      const url = new URL('http://localhost:3000/api/v1/tasks');
      const request = new NextRequest(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await GET(request);
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
      expect(responseData.data).toHaveLength(2);
      expect(responseData.data[0].title).toBe('Test Task 1');
      expect(responseData.data[1].completed).toBe(true);
      expect(responseData.data[0].user.id).toBe(mockUserId);
      expect(responseData.responseMeta.pagination.total).toBe(2);
    });

    test('should handle pagination parameters', async () => {
      mockQueryWithRLS.mockResolvedValueOnce([{ count: '10' }]);
      mockQueryWithRLS.mockResolvedValueOnce([]);

      const url = new URL('http://localhost:3000/api/v1/tasks?page=2&limit=5');
      const request = new NextRequest(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await GET(request);
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.responseMeta.pagination.page).toBe(2);
      expect(responseData.responseMeta.pagination.limit).toBe(5);
      expect(responseData.responseMeta.pagination.total).toBe(10);
    });

    test('should filter by completed status', async () => {
      mockQueryWithRLS.mockResolvedValueOnce([{ count: '1' }]);
      mockQueryWithRLS.mockResolvedValueOnce([{
        id: 'task-completed',
        title: 'Completed Task',
        description: 'This task is done',
        completed: true,
        userId: mockUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      }]);

      const url = new URL('http://localhost:3000/api/v1/tasks?completed=true');
      const request = new NextRequest(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await GET(request);
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.data[0].completed).toBe(true);
    });

    test('should reject without API key', async () => {
      const url = new URL('http://localhost:3000/api/v1/tasks');
      const request = new NextRequest(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      mockValidateApiKey.mockResolvedValueOnce({
        isValid: false,
        error: 'Missing API key'
      });

      const response = await GET(request);
      const responseData = await response.json();

      expect(response.status).toBe(401);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('MISSING_API_KEY');
    });
  });

  describe('POST /api/v1/tasks', () => {
    test('should create task successfully', async () => {
      const newTask = {
        id: mockTaskId,
        title: 'New Task',
        description: 'A newly created task',
        completed: false,
        userId: mockUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      };

      mockMutateWithRLS.mockResolvedValueOnce({ rows: [newTask] });

      const requestBody = {
        title: 'New Task',
        description: 'A newly created task'
      };

      const request = new NextRequest('http://localhost:3000/api/v1/tasks', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(201);
      expect(responseData.success).toBe(true);
      expect(responseData.data.title).toBe('New Task');
      expect(responseData.data.completed).toBe(false);
      expect(responseData.data.userId).toBe(mockUserId);
    });

    test('should require title field', async () => {
      const requestBody = {
        description: 'Task without title'
      };

      const request = new NextRequest('http://localhost:3000/api/v1/tasks', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(400);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('VALIDATION_ERROR');
    });

    test('should create task for specific user when admin', async () => {
      // Mock admin API key
      mockValidateApiKey.mockResolvedValueOnce({
        isValid: true,
        keyData: {
          id: 'admin-key-id',
          name: 'Admin Key',
          scopes: ['admin:tasks', 'tasks:write'],
          userId: 'admin-user-id',
          isActive: true,
          usageCount: 0,
          lastUsed: null,
          expiresAt: null,
          createdAt: '2023-01-01T00:00:00Z',
          updatedAt: '2023-01-01T00:00:00Z'
        },
        rateLimitStatus: {
          limit: 100,
          remaining: 99,
          reset: Date.now() + 900000
        }
      });

      const targetUserId = 'target-user-123';
      const newTask = {
        id: mockTaskId,
        title: 'Admin Created Task',
        description: 'Task created by admin for another user',
        completed: false,
        userId: targetUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      };

      mockMutateWithRLS.mockResolvedValueOnce({ rows: [newTask] });

      const requestBody = {
        title: 'Admin Created Task',
        description: 'Task created by admin for another user',
        userId: targetUserId
      };

      const request = new NextRequest('http://localhost:3000/api/v1/tasks', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(201);
      expect(responseData.data.userId).toBe(targetUserId);
    });
  });

  describe('GET /api/v1/tasks/{id}', () => {
    test('should get task by id successfully', async () => {
      const mockTask = {
        id: mockTaskId,
        title: 'Specific Task',
        description: 'Task retrieved by ID',
        completed: false,
        userId: mockUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      };

      mockQueryWithRLS.mockResolvedValueOnce([mockTask]);

      const request = new NextRequest(`http://localhost:3000/api/v1/tasks/${mockTaskId}`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await GET_BY_ID(request, { params: { id: mockTaskId } });
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
      expect(responseData.data.id).toBe(mockTaskId);
      expect(responseData.data.title).toBe('Specific Task');
    });

    test('should return 404 for non-existent task', async () => {
      mockQueryWithRLS.mockResolvedValueOnce([]);

      const request = new NextRequest(`http://localhost:3000/api/v1/tasks/non-existent`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await GET_BY_ID(request, { params: { id: 'non-existent' } });
      const responseData = await response.json();

      expect(response.status).toBe(404);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('TASK_NOT_FOUND');
    });
  });

  describe('PATCH /api/v1/tasks/{id}', () => {
    test('should update task successfully', async () => {
      const updatedTask = {
        id: mockTaskId,
        title: 'Updated Task Title',
        description: 'Updated description',
        completed: true,
        userId: mockUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-02T00:00:00Z'
      };

      // Mock getting existing task
      mockQueryWithRLS.mockResolvedValueOnce([{
        id: mockTaskId,
        title: 'Original Title',
        description: 'Original description',
        completed: false,
        userId: mockUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      }]);

      // Mock update operation
      mockMutateWithRLS.mockResolvedValueOnce({ rows: [updatedTask] });

      const requestBody = {
        title: 'Updated Task Title',
        completed: true
      };

      const request = new NextRequest(`http://localhost:3000/api/v1/tasks/${mockTaskId}`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await PATCH(request, { params: { id: mockTaskId } });
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
      expect(responseData.data.title).toBe('Updated Task Title');
      expect(responseData.data.completed).toBe(true);
    });

    test('should reject update of non-existent task', async () => {
      mockQueryWithRLS.mockResolvedValueOnce([]);

      const requestBody = {
        title: 'New Title'
      };

      const request = new NextRequest(`http://localhost:3000/api/v1/tasks/non-existent`, {
        method: 'PATCH',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await PATCH(request, { params: { id: 'non-existent' } });
      const responseData = await response.json();

      expect(response.status).toBe(404);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('TASK_NOT_FOUND');
    });
  });

  describe('DELETE /api/v1/tasks/{id}', () => {
    test('should delete task successfully', async () => {
      // Mock getting existing task
      mockQueryWithRLS.mockResolvedValueOnce([{
        id: mockTaskId,
        title: 'Task to Delete',
        description: 'This task will be deleted',
        completed: false,
        userId: mockUserId,
        createdAt: '2023-01-01T00:00:00Z',
        updatedAt: '2023-01-01T00:00:00Z'
      }]);

      // Mock delete operation
      mockMutateWithRLS.mockResolvedValueOnce({ rows: [{ id: mockTaskId }] });

      const request = new NextRequest(`http://localhost:3000/api/v1/tasks/${mockTaskId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await DELETE(request, { params: { id: mockTaskId } });
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
      expect(responseData.data.deleted).toBe(true);
      expect(responseData.data.id).toBe(mockTaskId);
    });

    test('should return 404 when deleting non-existent task', async () => {
      mockQueryWithRLS.mockResolvedValueOnce([]);

      const request = new NextRequest(`http://localhost:3000/api/v1/tasks/non-existent`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await DELETE(request, { params: { id: 'non-existent' } });
      const responseData = await response.json();

      expect(response.status).toBe(404);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('TASK_NOT_FOUND');
    });
  });

  describe('Validation Tests', () => {
    test('should validate title field format', async () => {
      const requestBody = {
        title: '', // Empty title
        description: 'Valid description'
      };

      const request = new NextRequest('http://localhost:3000/api/v1/tasks', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(400);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('VALIDATION_ERROR');
    });

    test('should handle invalid completed field type', async () => {
      const requestBody = {
        title: 'Valid Title',
        description: 'Valid description',
        completed: 'invalid-boolean'
      };

      const request = new NextRequest('http://localhost:3000/api/v1/tasks', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(400);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('VALIDATION_ERROR');
    });
  });

  describe('Authorization Tests', () => {
    test('should reject without tasks:read scope', async () => {
      mockValidateApiKey.mockResolvedValueOnce({
        isValid: true,
        keyData: {
          id: 'limited-key-id',
          name: 'Limited Key',
          scopes: ['users:read'], // Missing tasks:read
          userId: mockUserId,
          isActive: true,
          usageCount: 0,
          lastUsed: null,
          expiresAt: null,
          createdAt: '2023-01-01T00:00:00Z',
          updatedAt: '2023-01-01T00:00:00Z'
        },
        rateLimitStatus: {
          limit: 100,
          remaining: 99,
          reset: Date.now() + 900000
        }
      });

      const url = new URL('http://localhost:3000/api/v1/tasks');
      const request = new NextRequest(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      const response = await GET(request);
      const responseData = await response.json();

      expect(response.status).toBe(403);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('INSUFFICIENT_PERMISSIONS');
    });

    test('should reject create without tasks:write scope', async () => {
      mockValidateApiKey.mockResolvedValueOnce({
        isValid: true,
        keyData: {
          id: 'readonly-key-id',
          name: 'Read Only Key',
          scopes: ['tasks:read'], // Missing tasks:write
          userId: mockUserId,
          isActive: true,
          usageCount: 0,
          lastUsed: null,
          expiresAt: null,
          createdAt: '2023-01-01T00:00:00Z',
          updatedAt: '2023-01-01T00:00:00Z'
        },
        rateLimitStatus: {
          limit: 100,
          remaining: 99,
          reset: Date.now() + 900000
        }
      });

      const requestBody = {
        title: 'New Task',
        description: 'Trying to create without permission'
      };

      const request = new NextRequest('http://localhost:3000/api/v1/tasks', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${validApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(403);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('INSUFFICIENT_PERMISSIONS');
    });
  });
});
