/**
 * Unit Tests - Documentation Registry Helper Functions
 *
 * Tests the auto-generated registry helper functions for documentation.
 * The registry is generated at build time but functions can be tested.
 *
 * Test Coverage:
 * - getAllDocSections() - returns all sections (public + superadmin)
 * - getPublicDocSections() - returns public sections only
 * - getSuperadminDocSections() - returns superadmin sections only
 * - findDocSection(slug) - finds section by slug in all sections
 * - findDocSectionInCategory(slug, category) - finds section in specific category
 * - findDocPage(sectionSlug, pageSlug) - finds page within section
 */

import { describe, it, expect, beforeAll } from '@jest/globals'

// Import from the generated registry
// These functions are generated by scripts/build/docs-registry.mjs
import {
  DOCS_REGISTRY,
  getAllDocSections,
  getPublicDocSections,
  getSuperadminDocSections,
  findDocSection,
  findDocSectionInCategory,
  findDocPage,
} from '@nextsparkjs/registries/docs-registry'
import type { DocSectionMeta, DocPageMeta } from '@nextsparkjs/core/types/docs'

describe('Documentation Registry', () => {
  describe('DOCS_REGISTRY structure', () => {
    it('should have public, superadmin, and all arrays', () => {
      expect(DOCS_REGISTRY).toHaveProperty('public')
      expect(DOCS_REGISTRY).toHaveProperty('superadmin')
      expect(DOCS_REGISTRY).toHaveProperty('all')
      expect(Array.isArray(DOCS_REGISTRY.public)).toBe(true)
      expect(Array.isArray(DOCS_REGISTRY.superadmin)).toBe(true)
      expect(Array.isArray(DOCS_REGISTRY.all)).toBe(true)
    })

    it('should have all as combination of public and superadmin', () => {
      const expectedLength = DOCS_REGISTRY.public.length + DOCS_REGISTRY.superadmin.length
      expect(DOCS_REGISTRY.all.length).toBe(expectedLength)
    })

    it('each section should have required properties', () => {
      DOCS_REGISTRY.all.forEach((section: DocSectionMeta) => {
        expect(section).toHaveProperty('title')
        expect(section).toHaveProperty('slug')
        expect(section).toHaveProperty('order')
        expect(section).toHaveProperty('pages')
        expect(section).toHaveProperty('source')
        expect(typeof section.title).toBe('string')
        expect(typeof section.slug).toBe('string')
        expect(typeof section.order).toBe('number')
        expect(Array.isArray(section.pages)).toBe(true)
        expect(['public', 'superadmin']).toContain(section.source)
      })
    })

    it('each page should have required properties', () => {
      DOCS_REGISTRY.all.forEach((section: DocSectionMeta) => {
        section.pages.forEach((page: DocPageMeta) => {
          expect(page).toHaveProperty('slug')
          expect(page).toHaveProperty('title')
          expect(page).toHaveProperty('order')
          expect(page).toHaveProperty('path')
          expect(page).toHaveProperty('source')
          expect(typeof page.slug).toBe('string')
          expect(typeof page.title).toBe('string')
          expect(typeof page.order).toBe('number')
          expect(typeof page.path).toBe('string')
          expect(['public', 'superadmin']).toContain(page.source)
        })
      })
    })

    it('sections should be sorted by order', () => {
      const checkSorted = (sections: DocSectionMeta[]) => {
        for (let i = 1; i < sections.length; i++) {
          expect(sections[i].order).toBeGreaterThanOrEqual(sections[i - 1].order)
        }
      }

      checkSorted(DOCS_REGISTRY.public)
      checkSorted(DOCS_REGISTRY.superadmin)
    })

    it('pages within sections should be sorted by order', () => {
      DOCS_REGISTRY.all.forEach((section: DocSectionMeta) => {
        for (let i = 1; i < section.pages.length; i++) {
          expect(section.pages[i].order).toBeGreaterThanOrEqual(section.pages[i - 1].order)
        }
      })
    })
  })

  describe('getAllDocSections()', () => {
    it('should return all sections from both public and superadmin', () => {
      const allSections = getAllDocSections()
      expect(allSections).toEqual(DOCS_REGISTRY.all)
    })

    it('should return sections with correct structure', () => {
      const allSections = getAllDocSections()
      expect(Array.isArray(allSections)).toBe(true)
      allSections.forEach(section => {
        expect(section).toHaveProperty('title')
        expect(section).toHaveProperty('slug')
        expect(section).toHaveProperty('pages')
      })
    })
  })

  describe('getPublicDocSections()', () => {
    it('should return only public sections', () => {
      const publicSections = getPublicDocSections()
      expect(publicSections).toEqual(DOCS_REGISTRY.public)
    })

    it('all returned sections should have source "public"', () => {
      const publicSections = getPublicDocSections()
      publicSections.forEach(section => {
        expect(section.source).toBe('public')
      })
    })

    it('should not include any superadmin sections', () => {
      const publicSections = getPublicDocSections()
      const superadminSlugs = DOCS_REGISTRY.superadmin.map(s => s.slug)
      publicSections.forEach(section => {
        // A section could theoretically have same slug in both categories
        // but should not have superadmin source
        expect(section.source).not.toBe('superadmin')
      })
    })
  })

  describe('getSuperadminDocSections()', () => {
    it('should return only superadmin sections', () => {
      const superadminSections = getSuperadminDocSections()
      expect(superadminSections).toEqual(DOCS_REGISTRY.superadmin)
    })

    it('all returned sections should have source "superadmin"', () => {
      const superadminSections = getSuperadminDocSections()
      superadminSections.forEach(section => {
        expect(section.source).toBe('superadmin')
      })
    })
  })

  describe('findDocSection()', () => {
    it('should find section by slug', () => {
      // Get first available section slug
      const firstSection = DOCS_REGISTRY.all[0]
      if (firstSection) {
        const found = findDocSection(firstSection.slug)
        expect(found).toBeDefined()
        expect(found?.slug).toBe(firstSection.slug)
        expect(found?.title).toBe(firstSection.title)
      }
    })

    it('should return undefined for non-existent slug', () => {
      const found = findDocSection('non-existent-section-xyz')
      expect(found).toBeUndefined()
    })

    it('should return undefined for empty string', () => {
      const found = findDocSection('')
      expect(found).toBeUndefined()
    })

    it('should be case-sensitive', () => {
      const firstSection = DOCS_REGISTRY.all[0]
      if (firstSection && firstSection.slug !== firstSection.slug.toUpperCase()) {
        const found = findDocSection(firstSection.slug.toUpperCase())
        expect(found).toBeUndefined()
      }
    })
  })

  describe('findDocSectionInCategory()', () => {
    it('should find public section in public category', () => {
      const firstPublic = DOCS_REGISTRY.public[0]
      if (firstPublic) {
        const found = findDocSectionInCategory(firstPublic.slug, 'public')
        expect(found).toBeDefined()
        expect(found?.slug).toBe(firstPublic.slug)
        expect(found?.source).toBe('public')
      }
    })

    it('should find superadmin section in superadmin category', () => {
      const firstSuperadmin = DOCS_REGISTRY.superadmin[0]
      if (firstSuperadmin) {
        const found = findDocSectionInCategory(firstSuperadmin.slug, 'superadmin')
        expect(found).toBeDefined()
        expect(found?.slug).toBe(firstSuperadmin.slug)
        expect(found?.source).toBe('superadmin')
      }
    })

    it('should return undefined when looking in wrong category', () => {
      const firstPublic = DOCS_REGISTRY.public[0]
      if (firstPublic) {
        // Try to find public section in superadmin category
        const found = findDocSectionInCategory(firstPublic.slug, 'superadmin')
        // Should be undefined unless same slug exists in both
        if (found) {
          expect(found.source).toBe('superadmin')
        } else {
          expect(found).toBeUndefined()
        }
      }
    })

    it('should return undefined for non-existent slug in any category', () => {
      const foundPublic = findDocSectionInCategory('non-existent-xyz', 'public')
      const foundSuperadmin = findDocSectionInCategory('non-existent-xyz', 'superadmin')
      expect(foundPublic).toBeUndefined()
      expect(foundSuperadmin).toBeUndefined()
    })
  })

  describe('findDocPage()', () => {
    it('should find page within section', () => {
      const firstSection = DOCS_REGISTRY.all[0]
      const firstPage = firstSection?.pages[0]
      if (firstSection && firstPage) {
        const found = findDocPage(firstSection.slug, firstPage.slug)
        expect(found).toBeDefined()
        expect(found?.slug).toBe(firstPage.slug)
        expect(found?.title).toBe(firstPage.title)
      }
    })

    it('should return undefined for non-existent section', () => {
      const found = findDocPage('non-existent-section', 'any-page')
      expect(found).toBeUndefined()
    })

    it('should return undefined for non-existent page in existing section', () => {
      const firstSection = DOCS_REGISTRY.all[0]
      if (firstSection) {
        const found = findDocPage(firstSection.slug, 'non-existent-page-xyz')
        expect(found).toBeUndefined()
      }
    })

    it('should return undefined for empty slugs', () => {
      expect(findDocPage('', '')).toBeUndefined()
      expect(findDocPage('', 'some-page')).toBeUndefined()
      const firstSection = DOCS_REGISTRY.all[0]
      if (firstSection) {
        expect(findDocPage(firstSection.slug, '')).toBeUndefined()
      }
    })

    it('found page should have correct path format', () => {
      const firstSection = DOCS_REGISTRY.all[0]
      const firstPage = firstSection?.pages[0]
      if (firstSection && firstPage) {
        const found = findDocPage(firstSection.slug, firstPage.slug)
        expect(found?.path).toBeDefined()
        // Path should end with .md
        expect(found?.path.endsWith('.md')).toBe(true)
      }
    })
  })

  describe('Edge Cases', () => {
    it('should handle special characters in slugs gracefully', () => {
      // These should return undefined, not throw
      expect(() => findDocSection('section/with/slash')).not.toThrow()
      expect(() => findDocSection('section?with=query')).not.toThrow()
      expect(() => findDocPage('section', 'page?with=query')).not.toThrow()
    })

    it('should handle whitespace in slugs', () => {
      const found = findDocSection(' ')
      expect(found).toBeUndefined()

      const foundPage = findDocPage(' ', ' ')
      expect(foundPage).toBeUndefined()
    })
  })
})
