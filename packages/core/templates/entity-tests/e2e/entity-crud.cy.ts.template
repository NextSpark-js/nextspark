/// <reference types="cypress" />

/**
 * {{ENTITY_PLURAL}} API - CRUD Tests
 *
 * Generated: {{TIMESTAMP}}
 * Session: {{SESSION_NAME}}
 *
 * Basic CRUD operations for /api/v1/{{ENTITY_SLUG}} endpoints
 * Uses superadmin API key for full access with team context
 */

import * as allure from 'allure-cypress'

const {{ENTITY_PASCAL}}APIController = require('../../src/controllers/{{ENTITY_PASCAL}}APIController.js')

describe('{{ENTITY_PLURAL}} API - CRUD Operations', {
  tags: ['@api', '@feat-{{ENTITY_SLUG}}', '@crud', '@regression', '@scope-{{SESSION_NAME}}']
}, () => {
  let api: any
  let createdEntities: any[] = []

  // Superadmin API key for testing
  // TODO: Replace with your test API key from fixtures or environment
  const SUPERADMIN_API_KEY = 'test_api_key_for_testing_purposes_only_not_a_real_secret_key_abc123'
  const TEAM_ID = 'team-tmt-001'
  const BASE_URL = Cypress.config('baseUrl') || 'http://localhost:5173'

  before(() => {
    // Initialize API controller with superadmin API key and team context
    api = new {{ENTITY_PASCAL}}APIController(BASE_URL, SUPERADMIN_API_KEY, TEAM_ID)
    cy.log('{{ENTITY_PASCAL}}APIController initialized')
    cy.log(`Base URL: ${BASE_URL}`)
    cy.log(`Team ID: ${TEAM_ID}`)
  })

  beforeEach(() => {
    allure.epic('API')
    allure.feature('{{ENTITY_PLURAL}}')
  })

  afterEach(() => {
    // Cleanup: Delete entities created during tests
    if (createdEntities.length > 0) {
      createdEntities.forEach((entity: any) => {
        if (entity && entity.id) {
          api.delete{{ENTITY_PASCAL}}(entity.id)
        }
      })
      createdEntities = []
    }
  })

  // ============================================================
  // GET /api/v1/{{ENTITY_SLUG}} - List {{ENTITY_PLURAL}}
  // ============================================================
  describe('GET /api/v1/{{ENTITY_SLUG}} - List {{ENTITY_PLURAL}}', () => {
    it('{{ENTITY_SLUG_UPPER}}_API_001: Should list {{ENTITY_PLURAL}} with valid API key', { tags: '@smoke' }, () => {
      allure.story('CRUD Operations')
      allure.severity('critical')
      api.get{{ENTITY_PASCAL}}s().then((response: any) => {
        api.validateSuccessResponse(response, 200)
        api.validatePaginatedResponse(response)
        expect(response.body.data).to.be.an('array')

        cy.log(`Found ${response.body.data.length} {{ENTITY_PLURAL}}`)
        cy.log(`Total: ${response.body.info.total}`)
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_002: Should list {{ENTITY_PLURAL}} with pagination', () => {
      api.get{{ENTITY_PASCAL}}s({ page: 1, limit: 5 }).then((response: any) => {
        api.validatePaginatedResponse(response)
        expect(response.body.info.page).to.eq(1)
        expect(response.body.info.limit).to.eq(5)
        expect(response.body.data.length).to.be.at.most(5)

        cy.log(`Page 1, Limit 5: Got ${response.body.data.length} {{ENTITY_PLURAL}}`)
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_003: Should reject request without API key', () => {
      const originalApiKey = api.apiKey
      api.setApiKey(null)

      api.get{{ENTITY_PASCAL}}s().then((response: any) => {
        expect(response.status).to.eq(401)
        expect(response.body.success).to.be.false
      })

      api.setApiKey(originalApiKey)
    })

    it('{{ENTITY_SLUG_UPPER}}_API_004: Should reject request without x-team-id', () => {
      const originalTeamId = api.teamId
      api.setTeamId(null)

      api.get{{ENTITY_PASCAL}}s().then((response: any) => {
        expect(response.status).to.eq(400)
        expect(response.body.success).to.be.false
        expect(response.body.code).to.eq('TEAM_CONTEXT_REQUIRED')
      })

      api.setTeamId(originalTeamId)
    })
  })

  // ============================================================
  // POST /api/v1/{{ENTITY_SLUG}} - Create {{ENTITY_PASCAL}}
  // ============================================================
  describe('POST /api/v1/{{ENTITY_SLUG}} - Create {{ENTITY_PASCAL}}', () => {
    it('{{ENTITY_SLUG_UPPER}}_API_010: Should create {{ENTITY_SINGULAR}} with valid data', { tags: '@smoke' }, () => {
      allure.story('CRUD Operations')
      allure.severity('critical')

      // TODO: Customize test data based on entity schema
      const data = api.generateRandom{{ENTITY_PASCAL}}Data({
        // Add required fields here
      })

      api.create{{ENTITY_PASCAL}}(data).then((response: any) => {
        api.validateSuccessResponse(response, 201)
        api.validate{{ENTITY_PASCAL}}Object(response.body.data)

        // TODO: Add entity-specific validations
        // expect(response.body.data.name).to.eq(data.name)

        createdEntities.push(response.body.data)
        cy.log(`Created {{ENTITY_SINGULAR}}: ${response.body.data.id}`)
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_011: Should create {{ENTITY_SINGULAR}} with minimal data', () => {
      // TODO: Customize with minimal required fields
      const data = api.generateRandom{{ENTITY_PASCAL}}Data()

      api.create{{ENTITY_PASCAL}}(data).then((response: any) => {
        api.validateSuccessResponse(response, 201)
        api.validate{{ENTITY_PASCAL}}Object(response.body.data)

        createdEntities.push(response.body.data)
        cy.log(`Created {{ENTITY_SINGULAR}} with defaults: ${response.body.data.id}`)
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_012: Should reject creation without x-team-id', () => {
      const originalTeamId = api.teamId
      api.setTeamId(null)

      const data = api.generateRandom{{ENTITY_PASCAL}}Data()

      api.create{{ENTITY_PASCAL}}(data).then((response: any) => {
        expect(response.status).to.eq(400)
        expect(response.body.success).to.be.false
        expect(response.body.code).to.eq('TEAM_CONTEXT_REQUIRED')
      })

      api.setTeamId(originalTeamId)
    })
  })

  // ============================================================
  // GET /api/v1/{{ENTITY_SLUG}}/{id} - Get {{ENTITY_PASCAL}} by ID
  // ============================================================
  describe('GET /api/v1/{{ENTITY_SLUG}}/{id} - Get {{ENTITY_PASCAL}} by ID', () => {
    let testEntity: any

    beforeEach(() => {
      const data = api.generateRandom{{ENTITY_PASCAL}}Data()

      api.create{{ENTITY_PASCAL}}(data).then((response: any) => {
        testEntity = response.body.data
        createdEntities.push(testEntity)
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_020: Should get {{ENTITY_SINGULAR}} by valid ID', () => {
      cy.then(() => {
        api.get{{ENTITY_PASCAL}}ById(testEntity.id).then((response: any) => {
          api.validateSuccessResponse(response, 200)
          api.validate{{ENTITY_PASCAL}}Object(response.body.data)

          expect(response.body.data.id).to.eq(testEntity.id)

          cy.log(`Got {{ENTITY_SINGULAR}} by ID: ${testEntity.id}`)
        })
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_021: Should return 404 for non-existent {{ENTITY_SINGULAR}}', () => {
      const nonExistentId = 'non-existent-id-12345'

      api.get{{ENTITY_PASCAL}}ById(nonExistentId).then((response: any) => {
        expect(response.status).to.eq(404)
        expect(response.body.success).to.be.false
      })
    })
  })

  // ============================================================
  // PATCH /api/v1/{{ENTITY_SLUG}}/{id} - Update {{ENTITY_PASCAL}}
  // ============================================================
  describe('PATCH /api/v1/{{ENTITY_SLUG}}/{id} - Update {{ENTITY_PASCAL}}', () => {
    let testEntity: any

    beforeEach(() => {
      const data = api.generateRandom{{ENTITY_PASCAL}}Data()

      api.create{{ENTITY_PASCAL}}(data).then((response: any) => {
        testEntity = response.body.data
        createdEntities.push(testEntity)
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_030: Should update {{ENTITY_SINGULAR}} with valid data', () => {
      // TODO: Customize update data based on entity schema
      const updateData = {
        // name: 'Updated Name'
      }

      cy.then(() => {
        api.update{{ENTITY_PASCAL}}(testEntity.id, updateData).then((response: any) => {
          api.validateSuccessResponse(response, 200)
          api.validate{{ENTITY_PASCAL}}Object(response.body.data)

          // TODO: Add entity-specific validations
          // expect(response.body.data.name).to.eq(updateData.name)
          expect(response.body.data.id).to.eq(testEntity.id)

          cy.log(`Updated {{ENTITY_SINGULAR}}: ${testEntity.id}`)
        })
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_031: Should return 404 for non-existent {{ENTITY_SINGULAR}}', () => {
      const nonExistentId = 'non-existent-id-12345'
      const updateData = { /* minimal update */ }

      api.update{{ENTITY_PASCAL}}(nonExistentId, updateData).then((response: any) => {
        expect(response.status).to.eq(404)
        expect(response.body.success).to.be.false
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_032: Should reject empty update body', () => {
      cy.then(() => {
        api.update{{ENTITY_PASCAL}}(testEntity.id, {}).then((response: any) => {
          expect(response.status).to.eq(400)
          expect(response.body.success).to.be.false
        })
      })
    })
  })

  // ============================================================
  // DELETE /api/v1/{{ENTITY_SLUG}}/{id} - Delete {{ENTITY_PASCAL}}
  // ============================================================
  describe('DELETE /api/v1/{{ENTITY_SLUG}}/{id} - Delete {{ENTITY_PASCAL}}', () => {
    let testEntity: any

    beforeEach(() => {
      const data = api.generateRandom{{ENTITY_PASCAL}}Data()

      api.create{{ENTITY_PASCAL}}(data).then((response: any) => {
        testEntity = response.body.data
        // Don't add to createdEntities - we'll delete manually
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_040: Should delete {{ENTITY_SINGULAR}} by valid ID', () => {
      cy.then(() => {
        api.delete{{ENTITY_PASCAL}}(testEntity.id).then((response: any) => {
          api.validateSuccessResponse(response, 200)
          expect(response.body.data.success).to.be.true
          expect(response.body.data.id).to.exist

          cy.log(`Deleted {{ENTITY_SINGULAR}}: ${testEntity.id}`)

          // Verify deletion
          api.get{{ENTITY_PASCAL}}ById(testEntity.id).then((getResponse: any) => {
            expect(getResponse.status).to.eq(404)
          })
        })
      })
    })

    it('{{ENTITY_SLUG_UPPER}}_API_041: Should return 404 for non-existent {{ENTITY_SINGULAR}}', () => {
      const nonExistentId = 'non-existent-id-12345'

      api.delete{{ENTITY_PASCAL}}(nonExistentId).then((response: any) => {
        expect(response.status).to.eq(404)
        expect(response.body.success).to.be.false
      })

      // Add testEntity to cleanup since we didn't delete it
      createdEntities.push(testEntity)
    })
  })

  // ============================================================
  // Integration Test - Complete CRUD Lifecycle
  // ============================================================
  describe('Integration - Complete CRUD Lifecycle', () => {
    it('{{ENTITY_SLUG_UPPER}}_API_100: Should complete full lifecycle: Create -> Read -> Update -> Delete', () => {
      // TODO: Customize test data
      const createData = api.generateRandom{{ENTITY_PASCAL}}Data()

      // 1. CREATE
      api.create{{ENTITY_PASCAL}}(createData).then((createResponse: any) => {
        api.validateSuccessResponse(createResponse, 201)
        const created = createResponse.body.data
        cy.log(`1. Created: ${created.id}`)

        // 2. READ
        api.get{{ENTITY_PASCAL}}ById(created.id).then((readResponse: any) => {
          api.validateSuccessResponse(readResponse, 200)
          expect(readResponse.body.data.id).to.eq(created.id)
          cy.log(`2. Read: ${created.id}`)

          // 3. UPDATE
          const updateData = {
            // TODO: Add update fields
          }
          api.update{{ENTITY_PASCAL}}(created.id, updateData).then((updateResponse: any) => {
            api.validateSuccessResponse(updateResponse, 200)
            cy.log(`3. Updated: ${created.id}`)

            // 4. DELETE
            api.delete{{ENTITY_PASCAL}}(created.id).then((deleteResponse: any) => {
              api.validateSuccessResponse(deleteResponse, 200)
              expect(deleteResponse.body.data.success).to.be.true
              cy.log(`4. Deleted: ${created.id}`)

              // 5. VERIFY DELETION
              api.get{{ENTITY_PASCAL}}ById(created.id).then((finalResponse: any) => {
                expect(finalResponse.status).to.eq(404)
                cy.log(`5. Verified deletion: 404`)
                cy.log('Full CRUD lifecycle completed successfully')
              })
            })
          })
        })
      })
    })
  })
})
