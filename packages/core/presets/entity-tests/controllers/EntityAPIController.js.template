/**
 * {{ENTITY_PASCAL}}APIController - Controller for interacting with the {{ENTITY_PLURAL}} API
 * Encapsulates all CRUD operations for /api/v1/{{ENTITY_SLUG}} endpoints
 *
 * Generated: {{TIMESTAMP}}
 * Session: {{SESSION_NAME}}
 *
 * Requires:
 * - API Key with {{ENTITY_SLUG}}:read, {{ENTITY_SLUG}}:write scopes (or superadmin with *)
 * - x-team-id header for team context
 */
const BaseAPIController = require('../controllers/BaseAPIController')
const entitiesConfig = require('../../fixtures/entities.json')

const { slug } = entitiesConfig.entities.{{ENTITY_SLUG}}

class {{ENTITY_PASCAL}}APIController extends BaseAPIController {
  /**
   * @param {string} baseUrl - Base URL for API requests
   * @param {string|null} apiKey - API key for authentication
   * @param {string|null} teamId - Team ID for x-team-id header
   */
  constructor(baseUrl = 'http://localhost:5173', apiKey = null, teamId = null) {
    super(baseUrl, apiKey, teamId, { slug })
  }

  // ============================================================
  // SEMANTIC ALIASES (for backward compatibility)
  // ============================================================

  /**
   * GET /api/v1/{{ENTITY_SLUG}} - Get list of {{ENTITY_PLURAL}}
   * @param {Object} options - Query options
   * @param {number} [options.page] - Page number
   * @param {number} [options.limit] - Results per page
   * @param {string} [options.metas] - Metadata parameter ('all', 'key1,key2', etc.)
   * @param {string} [options.search] - Search in searchable fields
   * @param {Object} [options.headers] - Additional headers
   * @returns {Cypress.Chainable} Cypress response
   */
  get{{ENTITY_PASCAL}}s(options = {}) {
    return this.list(options)
  }

  /**
   * GET /api/v1/{{ENTITY_SLUG}}/{id} - Get specific {{ENTITY_SINGULAR}} by ID
   * @param {string} id - {{ENTITY_PASCAL}} ID
   * @param {Object} options - Additional options
   * @returns {Cypress.Chainable} Cypress response
   */
  get{{ENTITY_PASCAL}}ById(id, options = {}) {
    return this.getById(id, options)
  }

  /**
   * POST /api/v1/{{ENTITY_SLUG}} - Create new {{ENTITY_SINGULAR}}
   * @param {Object} data - {{ENTITY_PASCAL}} data
   * @param {Object} options - Additional options
   * @returns {Cypress.Chainable} Cypress response
   */
  create{{ENTITY_PASCAL}}(data, options = {}) {
    return this.create(data, options)
  }

  /**
   * PATCH /api/v1/{{ENTITY_SLUG}}/{id} - Update {{ENTITY_SINGULAR}}
   * @param {string} id - {{ENTITY_PASCAL}} ID
   * @param {Object} updateData - Data to update
   * @param {Object} options - Additional options
   * @returns {Cypress.Chainable} Cypress response
   */
  update{{ENTITY_PASCAL}}(id, updateData, options = {}) {
    return this.update(id, updateData, options)
  }

  /**
   * DELETE /api/v1/{{ENTITY_SLUG}}/{id} - Delete {{ENTITY_SINGULAR}}
   * @param {string} id - {{ENTITY_PASCAL}} ID
   * @param {Object} options - Additional options
   * @returns {Cypress.Chainable} Cypress response
   */
  delete{{ENTITY_PASCAL}}(id, options = {}) {
    return this.delete(id, options)
  }

  // ============================================================
  // DATA GENERATORS
  // ============================================================

  /**
   * Generate random {{ENTITY_SINGULAR}} data for testing
   * @param {Object} overrides - Specific data to override
   * @returns {Object} Generated {{ENTITY_SINGULAR}} data
   */
  generateRandomData(overrides = {}) {
    return this.generateRandom{{ENTITY_PASCAL}}Data(overrides)
  }

  /**
   * Generate random {{ENTITY_SINGULAR}} data for testing
   *
   * TODO: Implement based on entity schema
   *
   * @param {Object} overrides - Specific data to override
   * @returns {Object} Generated {{ENTITY_SINGULAR}} data
   */
  generateRandom{{ENTITY_PASCAL}}Data(overrides = {}) {
    const timestamp = Date.now()
    const randomId = Math.random().toString(36).substring(2, 8)

    // TODO: Customize based on your entity's required/optional fields
    return {
      // Example fields - customize based on your entity:
      // name: `Test {{ENTITY_PASCAL}} ${randomId} - ${timestamp}`,
      // description: `Description for test {{ENTITY_SINGULAR}} created at ${new Date().toISOString()}`,
      // status: 'active',
      ...overrides
    }
  }

  /**
   * Create a test {{ENTITY_SINGULAR}} and return its data
   * @param {Object} data - {{ENTITY_PASCAL}} data (optional)
   * @returns {Cypress.Chainable} Promise resolving with created {{ENTITY_SINGULAR}} data
   */
  createTest{{ENTITY_PASCAL}}(data = {}) {
    return this.createTestEntity(data)
  }

  /**
   * Clean up a test {{ENTITY_SINGULAR}} (delete it)
   * @param {string} id - {{ENTITY_PASCAL}} ID
   * @returns {Cypress.Chainable} Delete response
   */
  cleanupTest{{ENTITY_PASCAL}}(id) {
    return this.cleanup(id)
  }

  // ============================================================
  // ENTITY-SPECIFIC VALIDATORS
  // ============================================================

  /**
   * Validate {{ENTITY_SINGULAR}} object structure
   *
   * TODO: Implement validation based on entity schema
   *
   * @param {Object} entity - {{ENTITY_PASCAL}} object
   * @param {boolean} allowMetas - If metas property is allowed
   */
  validate{{ENTITY_PASCAL}}Object(entity, allowMetas = false) {
    // Base fields (id, createdAt, updatedAt, teamId)
    this.validateBaseEntityFields(entity)

    // TODO: Add entity-specific field validations
    // Example:
    // expect(entity).to.have.property('name')
    // expect(entity.name).to.be.a('string')
    //
    // expect(entity).to.have.property('status')
    // expect(entity.status).to.be.oneOf(['active', 'inactive', 'archived'])

    // Validate metas if present
    if (allowMetas && entity.hasOwnProperty('metas')) {
      expect(entity.metas).to.be.an('object')
    }
  }

  // ============================================================
  // METADATA HELPERS (optional)
  // ============================================================

  /**
   * Generate sample metadata for testing
   *
   * TODO: Customize based on your entity's metadata needs
   *
   * @param {string} type - Type of metadata
   * @returns {Object} Sample metadata
   */
  generateSampleMetadata(type = 'uiPreferences') {
    const sampleMetas = {
      uiPreferences: {
        colorLabel: 'blue',
        collapsed: false,
        customIcon: 'star'
      },
      customFields: {
        // Add custom metadata fields here
      }
    }

    return { [type]: sampleMetas[type] || sampleMetas.uiPreferences }
  }
}

// Export class for use in tests
module.exports = {{ENTITY_PASCAL}}APIController

// For global use in Cypress
if (typeof window !== 'undefined') {
  window.{{ENTITY_PASCAL}}APIController = {{ENTITY_PASCAL}}APIController
}
