/**
 * Entity Registry Generator
 *
 * Generates entity-registry.ts and entity-registry.client.ts
 *
 * @module core/scripts/build/registry/generators/entity-registry
 */

import { join } from 'path'
import { getDiscoveredParentData } from '../discovery/parent-child.mjs'
import { convertCorePath } from '../config.mjs'

/**
 * Generate the main entity registry file
 * @param {Array} entities - Discovered entities
 * @param {object} config - Configuration object from getConfig()
 * @returns {string} Generated TypeScript content
 */
export function generateEntityRegistry(entities, config) {
  const outputFilePath = join(config.outputDir, 'entity-registry.ts')
  const imports = entities.map(entity =>
    `import { ${entity.exportName} } from '${entity.configPath}'`
  ).join('\n')

  const registryEntries = entities.map(entity => {
    // NEW STRUCTURE: Derive table name from slug automatically
    // For regular entities: use slug as tableName
    // For child entities: use parent_slug + '_' + entity_slug
    const tableName = entity.exportName ? (
      entity.parent
        ? `'${entity.parent}_' + (${entity.exportName}.slug || '${entity.name}')`
        : `${entity.exportName}.slug || '${entity.name}'`
    ) : (
      entity.parent
        ? `'${entity.parent}_${entity.name}'`
        : `'${entity.name}'`
    )

    return `  '${entity.name}': {
    name: '${entity.name}',
    config: ${entity.exportName},
    tableName: ${tableName},
    relativePath: '${entity.relativePath || entity.name}',
    depth: ${entity.depth || 0},
    parent: ${entity.parent ? `'${entity.parent}'` : 'null'},
    children: [${(entity.children || []).map(c => `'${c}'`).join(', ')}],
    hasComponents: ${entity.hasComponents},
    hasHooks: ${entity.hasHooks},
    hasMigrations: ${entity.hasMigrations},
    hasMessages: ${entity.hasMessages || false},
    hasAssets: ${entity.hasAssets || false},
    messagesPath: '${entity.messagesPath}',
    pluginContext: ${entity.pluginContext ? `{ pluginName: '${entity.pluginContext.pluginName}' }` : 'null'},
    themeContext: ${entity.themeContext ? `{ themeName: '${entity.themeContext.themeName}' }` : 'null'},
    isCore: ${entity.isCore || false},
    source: ${entity.source ? `'${entity.source}' as const` : 'undefined'}
  }`
  }).join(',\n')

  return `/**
 * Auto-generated Entity Registry
 *
 * Generated at: ${new Date().toISOString()}
 * Entities discovered: ${entities.length}
 *
 * DO NOT EDIT - This file is auto-generated by scripts/build-registry.mjs
 */

${imports}
import type { EntityConfig, ChildEntityDefinition } from '${convertCorePath('@/core/lib/entities/types', outputFilePath, config)}'

export interface EntityPluginContext {
  pluginName: string
}

export interface EntityThemeContext {
  themeName: string
}

export interface EntityRegistryEntry {
  name: string
  config: EntityConfig | ChildEntityDefinition
  tableName?: string
  relativePath: string
  depth: number
  parent: string | null
  children: string[]
  hasComponents: boolean
  hasHooks: boolean
  hasMigrations: boolean
  hasMessages: boolean
  hasAssets: boolean
  messagesPath: string
  pluginContext: EntityPluginContext | null
  themeContext: EntityThemeContext | null
  isCore?: boolean
  source?: 'core' | 'theme' | 'plugin'
}

export const ENTITY_REGISTRY = {
${registryEntries}
}

export type EntityName = keyof typeof ENTITY_REGISTRY

/**
 * Entity registry metadata
 */
export const ENTITY_METADATA = {
  totalEntities: ${entities.length},
  pluginEntities: ${entities.filter(e => e.pluginContext).length},
  themeEntities: ${entities.filter(e => e.themeContext).length},
  entitiesWithComponents: ${entities.filter(e => e.hasComponents).length},
  entitiesWithHooks: ${entities.filter(e => e.hasHooks).length},
  entitiesWithMigrations: ${entities.filter(e => e.hasMigrations).length},
  entitiesWithMessages: ${entities.filter(e => e.hasMessages).length},
  entitiesWithAssets: ${entities.filter(e => e.hasAssets).length},
  maxDepth: ${Math.max(...entities.map(e => e.depth || 0), 0)},
  generatedAt: '${new Date().toISOString()}',
  entities: [${entities.map(e => `'${e.name}'`).join(', ')}]
}

// Query functions have been moved to: @nextsparkjs/core/lib/entities/queries
// Import from there instead:
// import { getEntity, getRegisteredEntities, ... } from '@nextsparkjs/core/lib/entities/queries'
`
}

/**
 * Generate the client-safe entity registry
 * @param {Array} entities - Discovered entities
 * @param {object} config - Configuration object from getConfig()
 * @returns {string} Generated TypeScript content
 */
export function generateEntityRegistryClient(entities, config) {
  const outputFilePath = join(config.outputDir, 'entity-registry.client.ts')
  const entityNames = entities.map(e => `'${e.name}'`).join(' | ')

  // Import entity configurations to extract client-safe properties
  const imports = entities.map(entity =>
    `import { ${entity.exportName} } from '${entity.configPath}'`
  ).join('\n')

  const clientRegistryEntries = entities.map(entity => {
    // Use dynamic reference to extract client-safe properties from imported config
    // New EntityConfig structure: slug, names.singular, apiPath derived from slug
    // NOTE: apiPath should NOT include /api/v1/ prefix - EntityApiClient adds it
    const fallbackApiPath = `'${entity.name}'`
    const apiPathRef = entity.exportName
      ? `${entity.exportName}.slug || '${entity.name}'`
      : fallbackApiPath
    const displayNameRef = entity.exportName ? `${entity.exportName}.names?.singular || ${entity.exportName}.slug || '${entity.name}'` : `'${entity.name}'`
    const tableNameRef = entity.exportName ? `${entity.exportName}.slug` : `'${entity.name}'`

    return `  '${entity.name}': {
    name: '${entity.name}',
    apiPath: ${apiPathRef},
    tableName: ${tableNameRef},
    displayName: ${displayNameRef},
    relativePath: '${entity.relativePath || entity.name}',
    depth: ${entity.depth || 0},
    parent: ${entity.parent ? `'${entity.parent}'` : 'null'},
    children: [${(entity.children || []).map(c => `'${c}'`).join(', ')}],
    hasComponents: ${entity.hasComponents},
    hasHooks: ${entity.hasHooks},
    hasMigrations: ${entity.hasMigrations},
    hasMessages: ${entity.hasMessages || false},
    hasAssets: ${entity.hasAssets || false},
    messagesPath: '${entity.messagesPath}',
    pluginContext: ${entity.pluginContext ? `{ pluginName: '${entity.pluginContext.pluginName}' }` : 'null'},
    themeContext: ${entity.themeContext ? `{ themeName: '${entity.themeContext.themeName}' }` : 'null'},
    isCore: ${entity.isCore || false},
    source: ${entity.source ? `'${entity.source}'` : `'theme'`},
    access: ${entity.exportName}.access?.basePath ? {
      basePath: ${entity.exportName}.access.basePath
    } : undefined,
    features: {
      enabled: ${entity.exportName}.enabled !== false,
      canCreate: true,
      canEdit: true,
      canDelete: true,
      searchable: true,
      showInMenu: ${entity.exportName}.ui?.dashboard?.showInMenu !== false
    },
    builder: ${entity.exportName}.builder ? {
      enabled: ${entity.exportName}.builder.enabled,
      sidebarFields: ${entity.exportName}.builder.sidebarFields,
      public: ${entity.exportName}.builder.public,
      seo: ${entity.exportName}.builder.seo
    } : undefined,
    taxonomies: ${entity.exportName}.taxonomies ? {
      enabled: ${entity.exportName}.taxonomies.enabled,
      types: ${entity.exportName}.taxonomies.types
    } : undefined
  }`
  }).join(',\n')

  // Generate slug to config mapping for backwards compatibility
  const slugMappings = entities.map(entity => {
    const slug = entity.apiPath || (entity.name.endsWith('s') ? entity.name : `${entity.name}s`)
    return `      '${slug}': '${entity.name}'`
  }).join(',\n')

  return `/**
 * Client-Safe Entity Registry
 *
 * Generated at: ${new Date().toISOString()}
 * Entities discovered: ${entities.length}
 *
 * This is the client-safe version of the entity registry.
 * Contains only configuration data safe for client components.
 * NO server-side imports or server-only dependencies.
 *
 * DO NOT EDIT - This file is auto-generated by scripts/build-registry.mjs
 */

${imports}

export interface ClientEntityConfig {
  name: string
  apiPath: string
  tableName?: string
  displayName: string
  relativePath: string
  depth: number
  parent: string | null
  children: string[]
  hasComponents: boolean
  hasHooks: boolean
  hasMigrations: boolean
  hasMessages: boolean
  hasAssets: boolean
  messagesPath: string
  pluginContext: { pluginName: string } | null
  themeContext: { themeName: string } | null
  isCore: boolean
  source: 'core' | 'theme' | 'plugin'
  access?: {
    basePath?: string
  }
  features: {
    enabled: boolean
    canCreate?: boolean
    canEdit?: boolean
    canDelete?: boolean
    searchable?: boolean
    showInMenu?: boolean
  }
  builder?: {
    enabled: boolean
    sidebarFields?: string[]
    public?: { basePath: string }
    seo?: boolean
  }
  taxonomies?: {
    enabled: boolean
    types: { type: string; field: string; multiple: boolean; label?: string }[]
  }
}

export interface ClientEntityRegistry {
  [key: string]: ClientEntityConfig
}

// Entity name type for type safety
export type EntityName = ${entities.length > 0 ? entityNames : 'never'}

// Client-safe entity registry (no server-side imports)
export const ENTITY_REGISTRY: ClientEntityRegistry = {
${clientRegistryEntries}
}

// Slug to config name mapping for backwards compatibility
const SLUG_TO_CONFIG_MAP: Record<string, string> = {
${slugMappings}
}

// ==================== Helper Functions ====================

/**
 * Get all registered entities
 */
export function getRegisteredEntities(): ClientEntityConfig[] {
  return Object.values(ENTITY_REGISTRY)
}

/**
 * Get entity by name
 */
export function getEntity(name: EntityName): ClientEntityConfig | undefined {
  return ENTITY_REGISTRY[name]
}

/**
 * Get entity by slug (for backwards compatibility)
 */
export function getEntityBySlug(slug: string): ClientEntityConfig | null {
  const configName = SLUG_TO_CONFIG_MAP[slug] || slug
  return ENTITY_REGISTRY[configName] || null
}

/**
 * Get API path for entity
 */
export function getEntityApiPath(entityType: string): string | null {
  // Check if this is a child entity first
  const childInfo = parseChildEntity(entityType)
  if (childInfo.isChild) {
    // For child entities, we need special handling
    return null
  }

  // Use entity registry lookup
  const entity = ENTITY_REGISTRY[entityType] || getEntityBySlug(entityType)
  return entity?.apiPath || null
}


/**
 * Check if entity exists
 */
export function hasEntity(name: string): boolean {
  return name in ENTITY_REGISTRY || getEntityBySlug(name) !== null
}

/**
 * Get entity display name
 */
export function getEntityDisplayName(slug: string): string {
  const entity = getEntityBySlug(slug) || ENTITY_REGISTRY[slug]
  return entity?.displayName || slug
}

// ==================== Client Meta System Adapter (Backwards Compatibility) ====================

/**
 * Client-safe meta system adapter for backwards compatibility
 */
export const clientMetaSystemAdapter = {
  /**
   * Get client-safe entity configuration
   */
  getEntityConfig: (entityType: string): ClientEntityConfig | undefined => {
    return getEntityBySlug(entityType) || ENTITY_REGISTRY[entityType]
  },

  /**
   * Get all client-safe entity configurations
   */
  getAllEntityConfigs: (): ClientEntityConfig[] => {
    return getRegisteredEntities()
  },

  /**
   * Check if entity exists in client-safe system
   */
  hasEntity: (entityType: string): boolean => {
    return hasEntity(entityType)
  },

  /**
   * Get API path for an entity (client-safe)
   */
  getApiPath: (entityType: string): string | null => {
    return getEntityApiPath(entityType)
  }
}

// ==================== Client Entity Registry (Backwards Compatibility) ====================

/**
 * Client entity registry for backwards compatibility
 */
export const clientEntityRegistry = {
  /**
   * Get entity config by slug (client-safe)
   */
  getBySlug: (slug: string): ClientEntityConfig | null => {
    return getEntityBySlug(slug)
  },

  /**
   * Get all available entity configs (client-safe)
   */
  getAll: (): ClientEntityConfig[] => {
    return getRegisteredEntities()
  },

  /**
   * Check if entity exists by slug (client-safe)
   */
  hasEntity: (slug: string): boolean => {
    return hasEntity(slug)
  },

  /**
   * Get entity display name by slug (client-safe)
   */
  getDisplayName: (slug: string): string => {
    return getEntityDisplayName(slug)
  }
}

/**
 * Client-safe version of ensureInitialized
 * Returns immediately since client config is static
 */
export async function ensureClientInitialized(): Promise<void> {
  // Client-side configs are always "initialized" since they're static
  return Promise.resolve()
}

// ==================== Child Entity Parsing ====================

/**
 * Parse child entity information (client-safe with baked-in discovery data)
 * Generated at build time with discovered parent-child relationships
 */
export function parseChildEntity(entityType: string): { isChild: boolean; parentEntity?: string; childType?: string } {
  // Baked-in parent entities discovered at build time
  const parentEntities: string[] = ` + JSON.stringify(getDiscoveredParentData()?.parentEntities || []) + `

  // Baked-in child type mappings discovered at build time
  const childTypeMappings: Record<string, string> = ` + JSON.stringify(getDiscoveredParentData()?.childTypeMappings || {}) + `

  // Check against discovered parent entities
  for (const parent of parentEntities) {
    if (entityType.startsWith(parent + '_')) {
      const childSingular = entityType.substring(parent.length + 1) // Remove "parent_"

      // Use discovered child type mappings
      const childType = childTypeMappings[childSingular] || childSingular + 's'

      return {
        isChild: true,
        parentEntity: parent,
        childType
      }
    }
  }

  return { isChild: false }
}

// ==================== Legacy Type Definitions ====================

export type ClientEntityType = EntityName
`
}
