/**
 * Template Registry Generator
 *
 * Generates template-registry.ts and template-registry.client.ts
 *
 * @module core/scripts/build/registry/generators/template-registry
 */

import { readFile } from 'fs/promises'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'

import { verbose } from '../../../utils/index.mjs'
import {
  canOverrideComponent
} from '../../../../dist/config/protected-paths.js'
import { convertCorePath } from '../config.mjs'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
// Path from packages/core/scripts/build/registry/generators/ to project root
// packages/core/scripts/build/registry/generators -> packages/core/scripts/build/registry -> packages/core/scripts/build -> packages/core/scripts -> packages/core -> packages -> root
const rootDir = join(__dirname, '../../../../../..')

/**
 * Generate the template registry file
 * @param {Array} templates - Discovered templates
 * @param {object} config - Configuration object from getConfig()
 * @returns {string} Generated TypeScript content
 */
export function generateTemplateRegistry(templates, config) {
  // Group templates by app path to handle multiple themes overriding the same path
  const templatesByPath = {}

  templates.forEach(template => {
    if (!templatesByPath[template.appPath]) {
      templatesByPath[template.appPath] = []
    }
    templatesByPath[template.appPath].push(template)
  })

  // Sort templates by priority (higher priority first)
  Object.keys(templatesByPath).forEach(appPath => {
    templatesByPath[appPath].sort((a, b) => b.priority - a.priority)
  })

  // Generate dynamic imports only for templates that can override components
  const templateImports = Object.entries(templatesByPath)
    .map(([appPath, pathTemplates], index) => {
      const highestPriorityTemplate = pathTemplates[0]
      const safeName = `Template_${index}`
      // Ensure .tsx extension is included for Windows compatibility
      let templatePath = highestPriorityTemplate.templatePath
      if (!templatePath.endsWith('.tsx') && !templatePath.endsWith('.ts')) {
        templatePath += '.tsx'
      }

      // Skip import for metadata-only templates (PROTECTED_RENDER)
      if (!canOverrideComponent(appPath)) {
        return `// ${safeName} skipped - PROTECTED_RENDER (metadata-only)`
      }

      return `import ${safeName} from '${templatePath}'`
    })
    .join('\n')

  // Generate registry entries
  const registryEntries = Object.entries(templatesByPath)
    .map(([appPath, pathTemplates], index) => {
      const highestPriorityTemplate = pathTemplates[0]
      const safeName = `Template_${index}`

      // For metadata-only templates (PROTECTED_RENDER), don't reference component
      const componentRef = canOverrideComponent(appPath) ? safeName : 'null'

      return `  '${appPath}': {
    appPath: '${appPath}',
    component: ${componentRef},
    template: ${JSON.stringify(highestPriorityTemplate, null, 4).replace(/^/gm, '    ')},
    alternatives: ${JSON.stringify(pathTemplates.slice(1), null, 4).replace(/^/gm, '    ')}
  }`
    })
    .join(',\n')

  // Generate utility functions for template resolution
  const templatePaths = Object.keys(templatesByPath)
  const templateTypeMap = {}

  templates.forEach(template => {
    if (!templateTypeMap[template.templateType]) {
      templateTypeMap[template.templateType] = []
    }
    templateTypeMap[template.templateType].push(template.appPath)
  })

  return `/**
 * Auto-generated Template Registry
 *
 * Generated at: ${new Date().toISOString()}
 * Templates discovered: ${templates.length}
 * App paths with overrides: ${templatePaths.length}
 *
 * DO NOT EDIT - This file is auto-generated by scripts/build-registry.mjs
 */

${templateImports}

export interface TemplateOverride {
  name: string
  themeName: string
  templateType: string
  fileName: string
  relativePath: string
  appPath: string
  templatePath: string
  priority: number
  metadata?: any
}

export interface TemplateRegistryEntry {
  appPath: string
  component: any
  template: TemplateOverride
  alternatives: TemplateOverride[]
}

export const TEMPLATE_REGISTRY: Record<string, TemplateRegistryEntry> = {
${registryEntries}
}

export type TemplatePath = keyof typeof TEMPLATE_REGISTRY extends never ? string : keyof typeof TEMPLATE_REGISTRY

/**
 * Template registry metadata
 */
export const TEMPLATE_METADATA = {
  totalTemplates: ${templates.length},
  uniquePaths: ${templatePaths.length},
  templateTypes: ${JSON.stringify(Object.keys(templateTypeMap))},
  themeDistribution: ${JSON.stringify(
    templates.reduce((acc, t) => {
      acc[t.themeName] = (acc[t.themeName] || 0) + 1
      return acc
    }, {})
  )},
  generatedAt: '${new Date().toISOString()}',
  paths: [${templatePaths.map(p => `'${p}'`).join(', ')}]
}
`
}

/**
 * Check if a template file has server-only exports
 * Server-only exports: generateMetadata, generateStaticParams, revalidate, dynamic, fetchCache, runtime
 * @param {string} filePath - Path to the template file
 * @returns {Promise<boolean>} Whether the file has server-only exports
 */
async function hasServerOnlyExports(filePath) {
  try {
    const content = await readFile(filePath, 'utf8')
    // Check for server-only function exports
    const serverFunctionExports = [
      /export\s+(async\s+)?function\s+generateMetadata/,
      /export\s+(async\s+)?function\s+generateStaticParams/,
    ]
    // Check for server-only const exports
    const serverConstExports = [
      /export\s+const\s+revalidate\s*=/,
      /export\s+const\s+dynamic\s*=/,
      /export\s+const\s+fetchCache\s*=/,
      /export\s+const\s+runtime\s*=/,
    ]

    for (const pattern of [...serverFunctionExports, ...serverConstExports]) {
      if (pattern.test(content)) {
        return true
      }
    }
    return false
  } catch {
    return false
  }
}

/**
 * Generate client-safe template registry with static imports
 * Only includes page templates that can be safely imported in client components
 * Excludes templates with server-only exports (generateMetadata, revalidate, etc.)
 * @param {Array} templates - Discovered templates
 * @param {object} config - Configuration object from getConfig()
 * @returns {Promise<string>} Generated TypeScript content
 */
export async function generateTemplateRegistryClient(templates, config) {
  const outputFilePath = join(config.outputDir, 'template-registry.client.ts')
  // Group templates by app path
  const templatesByPath = {}

  templates.forEach(template => {
    if (!templatesByPath[template.appPath]) {
      templatesByPath[template.appPath] = []
    }
    templatesByPath[template.appPath].push(template)
  })

  // Sort templates by priority (higher priority first)
  Object.keys(templatesByPath).forEach(appPath => {
    templatesByPath[appPath].sort((a, b) => b.priority - a.priority)
  })

  // Filter for client-compatible templates (pages only, not layouts)
  // Also exclude templates with server-only exports
  const clientCompatibleTemplatesPromises = Object.entries(templatesByPath)
    .filter(([appPath, pathTemplates]) => {
      const template = pathTemplates[0]
      // Only include page templates (not layouts) that can override components
      return template.templateType === 'page' && canOverrideComponent(appPath)
    })
    .map(async ([appPath, pathTemplates]) => {
      const template = pathTemplates[0]
      // Get actual file path from template path
      // Template paths may or may not have extension, ensure we check the .tsx file
      // In npm mode, use config.projectRoot instead of rootDir (which is relative to script)
      const projectRoot = config.projectRoot || rootDir
      let actualFilePath = template.templatePath.replace('@/', projectRoot + '/')
      // If path doesn't end with .tsx or .ts, add .tsx
      if (!actualFilePath.endsWith('.tsx') && !actualFilePath.endsWith('.ts')) {
        actualFilePath += '.tsx'
      }

      // Check for server-only exports
      const hasServerExports = await hasServerOnlyExports(actualFilePath)
      if (hasServerExports) {
        verbose(`Excluding ${appPath} from client registry (has server-only exports)`)
        return null
      }
      return [appPath, pathTemplates]
    })

  const clientCompatibleTemplatesResults = await Promise.all(clientCompatibleTemplatesPromises)
  const clientCompatibleTemplates = clientCompatibleTemplatesResults.filter(Boolean)

  // Generate static imports
  const templateImports = clientCompatibleTemplates
    .map(([appPath, pathTemplates], index) => {
      const template = pathTemplates[0]
      const safeName = `ClientTemplate_${index}`
      // Ensure .tsx extension is included for Windows compatibility
      let templatePath = template.templatePath
      if (!templatePath.endsWith('.tsx') && !templatePath.endsWith('.ts')) {
        templatePath += '.tsx'
      }
      return `import ${safeName} from '${templatePath}'`
    })
    .join('\n')

  // Generate registry entries with direct component references
  const registryEntries = clientCompatibleTemplates
    .map(([appPath, pathTemplates], index) => {
      const safeName = `ClientTemplate_${index}`
      return `  '${appPath}': ${safeName}`
    })
    .join(',\n')

  return `/**
 * Auto-generated Client Template Registry
 *
 * Generated at: ${new Date().toISOString()}
 * Client-compatible templates: ${clientCompatibleTemplates.length}
 *
 * DO NOT EDIT - This file is auto-generated by scripts/build-registry.mjs
 */

'use client'

import { ComponentType } from 'react'
import { isProtectedPath } from '${convertCorePath('@/core/config/protected-paths', outputFilePath, config)}'

${templateImports}

// Client-safe registry with static imports (auto-generated)
const CLIENT_TEMPLATE_REGISTRY: Record<string, ComponentType<any>> = {
${registryEntries}
}

/**
 * Check if template override exists (client-safe)
 */
export function hasTemplateOverrideClient(appPath: string): boolean {
  return appPath in CLIENT_TEMPLATE_REGISTRY
}

/**
 * Get template component with static import (client-safe)
 * Use this in client components to avoid metadata conflicts
 */
export function getTemplateOrDefaultClient<T extends ComponentType<any>>(
  appPath: string,
  defaultComponent: T
): T {
  // Check if path is protected
  if (isProtectedPath(appPath)) {
    return defaultComponent
  }

  // Check if template override exists
  if (!hasTemplateOverrideClient(appPath)) {
    return defaultComponent
  }

  // Return statically imported template component
  const TemplateComponent = CLIENT_TEMPLATE_REGISTRY[appPath]
  return TemplateComponent as T
}

/**
 * Higher-order component for template overrides (client-safe)
 */
export function withTemplateOverrideForClient<P extends object>(appPath: string) {
  return function<T extends ComponentType<P>>(WrappedComponent: T): T {
    return getTemplateOrDefaultClient(appPath, WrappedComponent)
  }
}
`
}
