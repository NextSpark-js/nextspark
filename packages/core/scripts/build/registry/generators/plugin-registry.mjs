/**
 * Plugin Registry Generator
 *
 * Generates plugin-registry.ts and plugin-registry.client.ts
 *
 * @module core/scripts/build/registry/generators/plugin-registry
 */

import { join } from 'path'
import { convertCorePath } from '../config.mjs'

/**
 * Generate the main plugin registry file
 * @param {Array} plugins - Discovered plugins
 * @param {object} config - Configuration object from getConfig()
 * @returns {string} Generated TypeScript content
 */
export function generatePluginRegistry(plugins, config) {
  const outputFilePath = join(config.outputDir, 'plugin-registry.ts')
  const configImports = plugins.map(plugin =>
    `import { ${plugin.exportName} } from '${plugin.configPath}'`
  ).join('\n')

  // NOTE: NO imports directos de route handlers para evitar dependencias problemÃ¡ticas de plugins
  // Los plugins manejan sus propias dependencias independientemente

  const imports = configImports

  // Generate route metadata only (no handlers to avoid plugin dependency issues)
  const routeMetadataMap = plugins
    .flatMap(plugin => (plugin.routeFiles || []).map(route => ({
      path: route.path,
      methods: route.methods,
      plugin: plugin.name,
      filePath: route.filePath
    })))
    .map(item => {
      return `  '${item.path}': {
    plugin: '${item.plugin}',
    methods: ${JSON.stringify(item.methods)},
    filePath: '${item.filePath}'
  }`
    })
    .join(',\n')

  const registryEntries = plugins.map(plugin =>
    `  '${plugin.name}': {
    name: '${plugin.name}',
    config: ${plugin.exportName},
    hasAPI: ${plugin.hasAPI},
    apiPath: ${plugin.apiPath ? `'${plugin.apiPath}'` : 'null'},
    routeFiles: ${JSON.stringify(plugin.routeFiles, null, 6).replace(/^/gm, '    ')} as RouteFileEndpoint[],
    entities: ${JSON.stringify(plugin.entities || [], null, 6).replace(/^/gm, '    ')},
    hasMessages: ${plugin.hasMessages || false},
    hasAssets: ${plugin.hasAssets || false}
  }`
  ).join(',\n')

  return `/**
 * Auto-generated Plugin Registry - SERVER ONLY
 *
 * Generated at: ${new Date().toISOString()}
 * Plugins discovered: ${plugins.length}
 *
 * WARNING: This registry includes server-side route handlers and Node.js dependencies.
 * For client-side usage, import from './plugin-registry.client' instead.
 *
 * DO NOT EDIT - This file is auto-generated by scripts/build-registry.mjs
 */

import 'server-only'

${imports}
import type { PluginConfig } from '${convertCorePath('@/core/types/plugin', outputFilePath, config)}'

// Re-export PluginConfig for external use
export type { PluginConfig }

export interface RouteFileEndpoint {
  path: string
  filePath: string
  relativePath: string
  methods: string[]
  isRouteFile: boolean
}

export interface RouteHandler {
  plugin: string
  methods: string[]
  handlers: Record<string, any>
}

export interface PluginEntity {
  name: string
  exportName: string
  configPath: string
  actualConfigFile: string
  relativePath: string
  depth: number
  parent: string | null
  children: string[]
  hasComponents: boolean
  hasHooks: boolean
  hasMigrations: boolean
  hasMessages: boolean
  hasAssets: boolean
  messagesPath: string
  pluginContext: { pluginName: string } | null
}

export interface PluginRegistryEntry {
  name: string
  config: PluginConfig
  hasAPI: boolean
  apiPath: string | null
  routeFiles: RouteFileEndpoint[]
  entities: PluginEntity[]
  hasMessages: boolean
  hasAssets: boolean
}

export const PLUGIN_REGISTRY = {
${registryEntries}
}

export const ROUTE_METADATA = {
${routeMetadataMap}
}

export type PluginName = keyof typeof PLUGIN_REGISTRY

// ==================== Service Layer ====================
// Query functions have been moved to: @nextsparkjs/core/lib/services/plugin.service
// import { PluginService, usePlugin } from '@nextsparkjs/core/lib/services'

/**
 * Plugin registry metadata
 */
export const PLUGIN_METADATA = {
  totalPlugins: ${plugins.length},
  pluginsWithAPI: ${plugins.filter(p => p.hasAPI).length},
  pluginsWithEntities: ${plugins.filter(p => p.entities && p.entities.length > 0).length},
  pluginsWithMessages: ${plugins.filter(p => p.hasMessages).length},
  pluginsWithAssets: ${plugins.filter(p => p.hasAssets).length},
  totalRouteFiles: ${plugins.reduce((sum, p) => sum + (p.routeFiles?.length || 0), 0)},
  totalPluginEntities: ${plugins.reduce((sum, p) => sum + (p.entities?.length || 0), 0)},
  generatedAt: '${new Date().toISOString()}',
  plugins: [${plugins.map(p => `'${p.name}'`).join(', ')}]
}
`
}

/**
 * Generate the client-safe plugin registry
 * @param {Array} plugins - Discovered plugins
 * @param {object} config - Configuration object from getConfig()
 * @returns {string} Generated TypeScript content
 */
export function generatePluginRegistryClient(plugins, config) {
  const pluginNames = plugins.map(p => `'${p.name}'`).join(' | ')

  const clientRegistryEntries = plugins.map(plugin => {
    return `  '${plugin.name}': {
    name: '${plugin.name}',
    hasAPI: ${plugin.hasAPI},
    apiPath: ${plugin.apiPath ? `'${plugin.apiPath}'` : 'null'},
    entities: ${JSON.stringify(plugin.entities?.map(e => e.name) || [], null, 4).replace(/^/gm, '    ')},
    hasMessages: ${plugin.hasMessages || false},
    hasAssets: ${plugin.hasAssets || false}
  }`
  }).join(',\n')

  return `/**
 * Client-Safe Plugin Registry
 *
 * Generated at: ${new Date().toISOString()}
 * Plugins discovered: ${plugins.length}
 *
 * This is the client-safe version of the plugin registry.
 * Contains only configuration data, no server-side route handlers.
 *
 * DO NOT EDIT - This file is auto-generated by scripts/build-registry.mjs
 */

export interface ClientPluginConfig {
  name: string
  hasAPI: boolean
  apiPath: string | null
  entities: string[]
  hasMessages: boolean
  hasAssets: boolean
}

export interface ClientPluginRegistry {
  [key: string]: ClientPluginConfig
}

// Plugin name type for type safety
export type PluginName = ${plugins.length > 0 ? pluginNames : 'never'}

// Client-safe plugin registry (no server-side imports)
export const PLUGIN_REGISTRY: ClientPluginRegistry = {
${clientRegistryEntries}
}

// Helper functions
export function getPlugin(name: string): ClientPluginConfig | null {
  return (PLUGIN_REGISTRY as any)[name] || null
}

export function getAllPlugins(): ClientPluginConfig[] {
  return Object.values(PLUGIN_REGISTRY)
}

export function hasPlugin(name: string): boolean {
  return name in PLUGIN_REGISTRY
}

// React hook for using plugin in components
export function usePlugin(name: PluginName): ClientPluginConfig | null {
  return getPlugin(name)
}
`
}
